<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>RRF Licence Map</title>

  <!-- Bootstrap -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    /* Minimal CSS: only what Bootstrap/Leaflet can't do */
    html, body { height: 100%; }
    
    :root { --nav-h: 0px; }

    /* Mobile: account for sticky navbar */
    @media (max-width: 991.98px) {
      #map { height: calc(100dvh - var(--nav-h)); }
    }
    @media (min-width: 992px) {
      #map, #filtersCanvas { height: calc(100dvh - var(--nav-h)); }
    }

    /* Desktop: full height */
    /*
    @media (min-width: 992px) {
      #map { height: 100vh; }
    }
    */
    
    .offcanvas-lg { overflow: scroll; }
    
    .swatch-dot { width: 10px; height: 10px; border-radius: 999px; display: inline-block; }

    /* make the filters pane scroll nicely on desktop */
    /*
    @media (min-width: 992px) {
      #filtersCanvas { height: 100vh; }
      #filtersCanvas .offcanvas-body { height: 100vh; overflow: auto; }
    }
    */

    .card { border-radius: unset; }

    .map-style-control {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 0.25rem;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
      padding: 0.5rem;
    }

    .map-style-control select {
      min-width: 160px;
    }

    #regionSection {
      position: relative;
      z-index: 2;
    }

    #addressSuggestions {
      z-index: 1050;
    }
  </style>
</head>
<body class="bg-body-tertiary">

  <!-- Mobile top bar -->
  <nav class="navbar navbar-expand-lg bg-body border-bottom sticky-top" id="topbar">
    <div class="container-fluid">
      <span class="navbar-brand fw-semibold">RRF Licence Map</span>
      <div class="d-flex gap-2">
        <button class="btn btn-outline-secondary" id="geoLocateBtn" type="button">
          Locate me
        </button>
        <button class="btn btn-outline-primary d-lg-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#filtersCanvas" aria-controls="filtersCanvas">
          Filters
        </button>
      </div>
    </div>
  </nav>

<div class="row g-0">

  <!-- Filters: offcanvas on mobile, static sidebar on lg+ -->
  <div class="col-12 col-lg-4 col-xl-3 border-end bg-body">
    <div class="offcanvas-lg offcanvas-start" tabindex="-1" id="filtersCanvas" aria-labelledby="filtersCanvasLabel">
      <div class="offcanvas-header d-lg-none">
        <h5 class="offcanvas-title" id="filtersCanvasLabel">Filters</h5>
        <button type="button"
                class="btn-close"
                data-bs-dismiss="offcanvas"
                data-bs-target="#filtersCanvas"
                aria-label="Close"></button>
      </div>
      <div class="offcanvas-body p-0">
        
<div class="d-grid">

  <div class="card d-none">
    <div class="card-body">
      <div class="text-secondary">
          <button class="btn btn-sm btn-outline-secondary" id="clearDetail" type="button">Clear selection</button>
      </div>
    </div>
  </div>

  <div class="card" id="carrierSection">
    <div class="card-body">
      <div class="fw-semibold mb-2">Carriers</div>
      <div class="btn-group gap-2 flex-wrap" role="group" aria-label="Carriers" id="carrierBtns"></div>
    </div>
  </div>

  <div class="card" id="bandSection">
    <div class="card-body">
        <div class="fw-semibold mb-2">Bands</div>
        <div class="btn-group gap-2 flex-wrap" role="group" aria-label="Bands" id="bandBtns"></div>
    </div>
  </div>

  <div class="card" id="regionSection">
    <div class="card-body">
      <div class="row g-2">
        <div class="col-12">
          <label class="form-label fw-semibold" for="qDistrict">District</label>
          <select class="form-select" id="qDistrict">
            <option value="">(any)</option>
          </select>
        </div>
        <div class="col-12">
          <label class="form-label fw-semibold" for="qLocation">Location</label>
          <input class="form-control" id="qLocation" type="text" placeholder="e.g. NAPIER, SYDENHAM…" />
        </div>
        <div class="col-12 position-relative">
          <label class="form-label fw-semibold" for="qAddress">Address search</label>
          <input class="form-control" id="qAddress" type="text" placeholder="Search address or lat,lon" autocomplete="off" />
          <div class="list-group position-absolute w-100 shadow-sm d-none" id="addressSuggestions"></div>
          <div class="form-text text-secondary" id="addressSearchStatus"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="card d-none">
    <div class="card-body">
      <div class="d-flex align-items-center justify-content-between">
        <div class="fw-semibold">Date filters</div>
        <button class="btn btn-sm btn-outline-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#dateCollapse" aria-expanded="false" aria-controls="dateCollapse">Toggle</button>
      </div>

      <div class="collapse mt-3" id="dateCollapse">
        <div class="row g-2">
          <div class="col-6">
            <label class="form-label" for="qCommFrom">Comm from</label>
            <input class="form-control" id="qCommFrom" type="date" />
          </div>
          <div class="col-6">
            <label class="form-label" for="qCommTo">Comm to</label>
            <input class="form-control" id="qCommTo" type="date" />
          </div>
          <div class="col-6">
            <label class="form-label" for="qExpFrom">Expiry from</label>
            <input class="form-control" id="qExpFrom" type="date" />
          </div>
          <div class="col-6">
            <label class="form-label" for="qExpTo">Expiry to</label>
            <input class="form-control" id="qExpTo" type="date" />
          </div>
        </div>
      </div>

    </div>
  </div>

  <div class="card" id="recentSection">
    <div class="card-body">
      <div class="d-flex align-items-center justify-content-between mb-2 gap-2">
        <div class="fw-semibold">10 most recent changes</div>
        <button class="btn btn-sm btn-outline-primary" id="recentUpdateButton" type="button">Update</button>
      </div>
      <div class="list-group" id="recentList"></div>
    </div>
  </div>

  <div class="card">
    <div class="card-body">
      <div class="fw-semibold mb-2">Details</div>
      <div id="detailCard" class="text-secondary"></div>
    </div>
  </div>

  <div class="text-secondary alert alert-warning d-none" id="coordWarn" role="alert"></div>

</div>

      </div>
    </div>
  </div>

  <!-- Map column -->
  <main class="col-12 col-lg-8 col-xl-9">
    <div id="map"></div>
  </main>

</div>

  <!-- libs -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <script>
    const DATA_URL = "https://raw.githubusercontent.com/codenui/rrf.codenui.co.nz/refs/heads/main/rrf_licences.json";
    const BAND_DEFS = [["b28", "LTE B28 (700)", [703, 803]], ["b5", "LTE B5 (850)", [824, 894]], ["b8", "LTE B8 (900)", [880, 960]], ["b3", "LTE B3 (1800)", [1710, 1880]], ["b1", "LTE/UMTS B1 (2100)", [1920, 2170]], ["b40", "LTE B40 (2300)", [2300, 2400]], ["b7", "LTE B7 (2600)", [2500, 2690]], ["n78", "NR n78 (3500)", [3300, 3800]], ["n258", "NR n258 (26GHz)", [24250, 27500]]]; // [code,label,[lo,hi]]
    let DATA = [];

    async function init() {
      const response = await fetch(DATA_URL, { cache: "no-store" });
      if (!response.ok) {
        throw new Error(`Failed to load data (${response.status}).`);
      }
      DATA = await response.json();

    // UI-only transforms (do not store in JSON)
    const DISTRICT_NAMES = {
      NL: "Northland",
      AK: "Auckland",
      WK: "Waikato",
      BP: "Bay of Plenty",
      GS: "Gisborne",
      TK: "Taranaki/King Country",
      TP: "Taupo",
      HB: "Hawke's Bay",
      MW: "Manawatu/Whanganui",
      WN: "Wellington",
      MB: "Marlborough",
      NT: "Nelson/Tasman",
      WC: "West Coast",
      CB: "Canterbury",
      OT: "Otago",
      SL: "Southland",
      NZ: "zzz Management Right",
    };

    const CARRIERS = {
      "2degrees": { color: "#009ED8", friendly: "2degrees" },
      "spark": { color: "rgb(64, 14, 125)", friendly: "Spark" },
      "one": { color: "#00A45F", friendly: "One NZ" },
      "rcg": { color: "#f68b1f", friendly: "RCG" },
      "tuatea": { color: "#000000", friendly: "Tu Atea" },
      "uber": { color: "#ec008c", friendly: "Uber" },
      "unknown": { color: "#666666", friendly: "Unknown" },
    };

    function carrierKeyFromLicensee(licensee) {
      if (!licensee) return "unknown";
      const s = String(licensee).toUpperCase();
      if (s.includes("TWO DEGREES")) return "2degrees";
      if (s.includes("SPARK")) return "spark";
      if (s.includes("ONE NEW ZEALAND") || s.includes("ONE NZ") || s.includes("VODAFONE")) return "one";
      if (s.includes("RURAL")) return "rcg";
      if (s.includes("TŪ ĀTEA") || s.includes("TU ATEA")) return "tuatea";
      if (s.includes("UBER")) return "uber";
      return "unknown";
    }

    function districtNamesFromCodes(codes) {
      const arr = Array.isArray(codes) ? codes : (codes ? [codes] : []);
      return arr.map(c => DISTRICT_NAMES[c] || c);
    }

    // Decorate records UI-side (still not changing the JSON file on disk)
    DATA.forEach(r => {
      const ck = carrierKeyFromLicensee(r.licensee);
      const meta = CARRIERS[ck] || CARRIERS.unknown;

      // cache derived values for UI convenience
      r.carrierKey = ck;
      r.carrierFriendly = meta.friendly;
      r.carrierColor = meta.color;

      r.locationDistrictNames = districtNamesFromCodes(r.locationDistrictCodes);
    });

    function parseDate(value) {
      if (!value) return null;
      const d = new Date(value + "T00:00:00");
      return isNaN(d.getTime()) ? null : d;
    }
    function parseISO(iso) {
      if (!iso) return null;
      const d = new Date(iso);
      return isNaN(d.getTime()) ? null : d;
    }
    function fmtDate(iso) {
      const d = parseISO(iso);
      if (!d) return "";
      return d.toISOString().slice(0, 10);
    }
    function safe(v) {
      return (v === null || v === undefined) ? "" : String(v);
    }

    // Map init
    const map = L.map("map");
    const baseLayers = {
      "OpenStreetMap": L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "&copy; OpenStreetMap contributors"
      }),
      "Topographic": L.tileLayer("https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png", {
        maxZoom: 17,
        attribution: "Map data: &copy; OpenStreetMap contributors, SRTM | Map style: &copy; OpenTopoMap (CC-BY-SA)"
      })
    };
    baseLayers.OpenStreetMap.addTo(map);
    map.setView([-41.2, 174.7], 5);

    const MapStyleControl = L.Control.extend({
      onAdd() {
        const div = L.DomUtil.create("div", "map-style-control");
        div.innerHTML = `
          <label class="form-label fw-semibold mb-1" for="mapStyleSelect">Map style</label>
          <select id="mapStyleSelect" class="form-select form-select-sm">
            ${Object.keys(baseLayers).map(name => `<option value="${name}">${name}</option>`).join("")}
          </select>
        `;
        L.DomEvent.disableClickPropagation(div);
        return div;
      }
    });
    const mapStyleControl = new MapStyleControl({ position: "topright" });
    map.addControl(mapStyleControl);

    const mapStyleSelect = document.getElementById("mapStyleSelect");
    if (mapStyleSelect) {
      mapStyleSelect.value = "OpenStreetMap";
      mapStyleSelect.addEventListener("change", (event) => {
        const selected = event.target.value;
        Object.entries(baseLayers).forEach(([name, layer]) => {
          if (map.hasLayer(layer)) {
            map.removeLayer(layer);
          }
          if (name === selected) {
            layer.addTo(map);
          }
        });
      });
    }

    let markersLayer = L.layerGroup().addTo(map);
    let addressMarker = null;
    let addressSuggestTimer = null;
    let addressSuggestController = null;
    let addressSuggestionsCache = [];

    function setAddressStatus(message, tone = "muted") {
      if (!addressSearchStatus) return;
      addressSearchStatus.textContent = message || "";
      addressSearchStatus.classList.remove("text-secondary", "text-danger", "text-success");
      if (tone === "danger") {
        addressSearchStatus.classList.add("text-danger");
      } else if (tone === "success") {
        addressSearchStatus.classList.add("text-success");
      } else {
        addressSearchStatus.classList.add("text-secondary");
      }
    }

    function zoomToAddress(lat, lon) {
      const coords = [lat, lon];
      map.setView(coords, 15);
      if (addressMarker) {
        addressMarker.remove();
      }
      addressMarker = L.marker(coords).addTo(map);
    }

    function hideAddressSuggestions() {
      if (!addressSuggestions) return;
      addressSuggestions.classList.add("d-none");
      addressSuggestions.innerHTML = "";
      addressSuggestionsCache = [];
    }

    function renderAddressSuggestions(results) {
      if (!addressSuggestions) return;
      addressSuggestions.innerHTML = "";
      addressSuggestionsCache = results;
      if (!results.length) {
        addressSuggestions.classList.add("d-none");
        return;
      }
      results.forEach((result, index) => {
        const item = document.createElement("button");
        item.type = "button";
        item.className = "list-group-item list-group-item-action";
        item.textContent = result.display_name;
        item.dataset.index = String(index);
        addressSuggestions.appendChild(item);
      });
      addressSuggestions.classList.remove("d-none");
    }

    async function fetchAddressSuggestions(query) {
      if (addressSuggestController) {
        addressSuggestController.abort();
      }
      addressSuggestController = new AbortController();
      const url = `https://nominatim.openstreetmap.org/search?format=json&limit=6&q=${encodeURIComponent(query)}`;
      const response = await fetch(url, {
        headers: { Accept: "application/json" },
        signal: addressSuggestController.signal
      });
      if (!response.ok) {
        throw new Error("Unable to reach search service.");
      }
      return response.json();
    }

    function parseLatLon(value) {
      if (!value) return null;
      const match = value.trim().match(/^(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)$/);
      if (!match) return null;
      const lat = Number(match[1]);
      const lon = Number(match[2]);
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
      if (lat < -90 || lat > 90 || lon < -180 || lon > 180) return null;
      return { lat, lon };
    }

    async function handleAddressSearch() {
      if (!qAddress) return;
      hideAddressSuggestions();
      const query = qAddress.value.trim();
      if (!query) {
        setAddressStatus("Enter an address to search.", "danger");
        return;
      }

      const latLon = parseLatLon(query);
      if (latLon) {
        zoomToAddress(latLon.lat, latLon.lon);
        setAddressStatus(`Zoomed to ${latLon.lat.toFixed(5)}, ${latLon.lon.toFixed(5)}.`, "success");
        return;
      }

      setAddressStatus("Searching…");
      try {
        const url = `https://nominatim.openstreetmap.org/search?format=json&limit=1&q=${encodeURIComponent(query)}`;
        const response = await fetch(url, { headers: { Accept: "application/json" } });
        if (!response.ok) {
          throw new Error("Unable to reach search service.");
        }
        const results = await response.json();
        if (!results || results.length === 0) {
          setAddressStatus("No results found. Try a more specific address.", "danger");
          return;
        }
        const best = results[0];
        const lat = Number(best.lat);
        const lon = Number(best.lon);
        if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
          setAddressStatus("Search result did not include usable coordinates.", "danger");
          return;
        }
        zoomToAddress(lat, lon);
        setAddressStatus(`Zoomed to ${best.display_name || query}.`, "success");
      } catch (err) {
        setAddressStatus(err?.message || "Search failed. Please try again.", "danger");
      }
    }

    let userMarker = null;
    
    function updateNavHeight() {
      const bar = document.getElementById("topbar");
      const h = bar ? bar.offsetHeight : 0;
      document.documentElement.style.setProperty("--nav-h", `${h}px`);
    }

    // Run now + on resize/orientation change
    updateNavHeight();
    window.addEventListener("resize", updateNavHeight);
    window.addEventListener("orientationchange", updateNavHeight);
    
    // UI refs
    const qDistrict = document.getElementById("qDistrict");
    const qLocation = document.getElementById("qLocation");
    const qAddress = document.getElementById("qAddress");
    const qCommFrom = document.getElementById("qCommFrom");
    const qCommTo = document.getElementById("qCommTo");
    const qExpFrom = document.getElementById("qExpFrom");
    const qExpTo = document.getElementById("qExpTo");
    const addressSuggestions = document.getElementById("addressSuggestions");

    const carrierBtns = document.getElementById("carrierBtns");
    const bandBtns = document.getElementById("bandBtns");

    const detailCard = document.getElementById("detailCard");
    const recentList = document.getElementById("recentList");
    const coordWarn = document.getElementById("coordWarn");
    const recentSection = document.getElementById("recentSection");
    const regionSection = document.getElementById("regionSection");
    const addressSearchStatus = document.getElementById("addressSearchStatus");
    const geoLocateBtn = document.getElementById("geoLocateBtn");

    function geolocateUser() {
      if (!navigator.geolocation) {
        window.alert("Geolocation is not supported by this browser.");
        return;
      }

      navigator.geolocation.getCurrentPosition(
        (position) => {
          const { latitude, longitude } = position.coords;
          if (userMarker) {
            userMarker.setLatLng([latitude, longitude]);
          } else {
            userMarker = L.circleMarker([latitude, longitude], {
              radius: 7,
              color: "#0d6efd",
              fillColor: "#0d6efd",
              fillOpacity: 0.7,
              weight: 2
            }).addTo(map);
          }
          map.setView([latitude, longitude], 12);
        },
        (error) => {
          window.alert(`Unable to fetch your location: ${error.message}`);
        },
        {
          enableHighAccuracy: true,
          timeout: 10000,
          maximumAge: 60000
        }
      );
    }

    geoLocateBtn?.addEventListener("click", geolocateUser);
    const carrierSection = document.getElementById("carrierSection");
    const bandSection = document.getElementById("bandSection");
    
    // District dropdown options
    function populateDistricts() {
      const mapD = new Map(); // code -> name
      DATA.forEach(r => {
        const codes = r.locationDistrictCodes || [];
        const names = r.locationDistrictNames || [];
        codes.forEach((c, i) => mapD.set(c, names[i] || c));
      });
      [...mapD.entries()].sort((a,b) => a[1].localeCompare(b[1])).forEach(([code, name]) => {
        const opt = document.createElement("option");
        opt.value = code;
        opt.textContent = name;
        qDistrict.appendChild(opt);
      });
    }
    populateDistricts();

    if (qAddress) {
      qAddress.addEventListener("keydown", event => {
        if (event.key === "Enter") {
          event.preventDefault();
          handleAddressSearch();
        }
      });
      qAddress.addEventListener("input", () => {
        const query = qAddress.value.trim();
        if (addressSuggestTimer) {
          clearTimeout(addressSuggestTimer);
        }
        if (query.length < 3) {
          hideAddressSuggestions();
          return;
        }
        addressSuggestTimer = setTimeout(async () => {
          try {
            const results = await fetchAddressSuggestions(query);
            renderAddressSuggestions(results || []);
          } catch (err) {
            if (err?.name === "AbortError") return;
            hideAddressSuggestions();
          }
        }, 250);
      });
      qAddress.addEventListener("blur", () => {
        setTimeout(() => hideAddressSuggestions(), 150);
      });
    }
    if (addressSuggestions) {
      addressSuggestions.addEventListener("click", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) return;
        const index = target.dataset.index;
        if (index === undefined) return;
        const result = addressSuggestionsCache[Number(index)];
        if (!result) return;
        const lat = Number(result.lat);
        const lon = Number(result.lon);
        if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
          setAddressStatus("Search result did not include usable coordinates.", "danger");
          return;
        }
        qAddress.value = result.display_name || qAddress.value;
        hideAddressSuggestions();
        zoomToAddress(lat, lon);
        setAddressStatus(`Zoomed to ${result.display_name || qAddress.value}.`, "success");
      });
    }

    // -------------------------------------------------------------------------
    // Carriers: "show all by default"
    // - selected set empty => show all
    // - click when empty => select only that one
    // - click additional => add
    // - click selected => remove
    // - removing last => back to show all
    // -------------------------------------------------------------------------
    const carrierSelected = new Set(); // empty => all
    let carrierAllKeys = [];

    function uniqueCarriers() {
      const m = new Map(); // key -> {friendly,color}
      DATA.forEach(r => {
        const k = r.carrierKey || "unknown";
        if (k === "uber") return;
        
        const friendly = r.carrierFriendly || k;
        const color = r.carrierColor || "#666";
        if (!m.has(k)) m.set(k, { friendly, color });
      });
      return [...m.entries()].sort((a,b) => a[1].friendly.localeCompare(b[1].friendly));
    }
    
    function updateAvailability(baseFiltered) {
      // Carriers that still have matches given current BAND selection
      const availCarriers = new Set(
        baseFiltered
          .filter(r => bandSelected.size === 0 || bandSelected.has(r.bandCode || "unknown"))
          .map(r => r.carrierKey || "unknown")
          .filter(k => k !== "uber") // keep your existing exclusion consistent
      );

      // Bands that still have matches given current CARRIER selection
      const availBands = new Set(
        baseFiltered
          .filter(r => carrierSelected.size === 0 || carrierSelected.has(r.carrierKey || "unknown"))
          .map(r => r.bandCode || "unknown")
      );

      // Disable carrier buttons that would yield zero results,
      // BUT never disable ones that are currently selected (so user can unselect).
      carrierBtns.querySelectorAll("button").forEach(btn => {
        const k = btn.dataset.key;
        const isSelected = carrierSelected.has(k);
        const ok = availCarriers.has(k);
        btn.disabled = (!ok && !isSelected);
        btn.classList.toggle("opacity-50", btn.disabled);
      });

      // Same for band buttons
      bandBtns.querySelectorAll("button").forEach(btn => {
        const code = btn.dataset.code;
        const isSelected = bandSelected.has(code);
        const ok = availBands.has(code);
        btn.disabled = (!ok && !isSelected);
        btn.classList.toggle("opacity-50", btn.disabled);
      });
    }

    function syncCarrierButtons() {
      const allMode = carrierSelected.size === 0;
      carrierBtns.querySelectorAll("button").forEach(b => {
        const k = b.dataset.key;
        const on = allMode ? true : carrierSelected.has(k);

        b.classList.toggle("btn-dark", on);
        b.classList.toggle("btn-outline-secondary", !on);
        b.setAttribute("aria-pressed", on ? "true" : "false");
      });
    }

    function buildCarrierUI() {
      carrierBtns.innerHTML = "";

      // Desired display order
      const primary = ["2degrees", "one", "spark"];
      const secondary = ["rcg", "tuatea"];

      const carriers = uniqueCarriers(); // [[key, {friendly,color}], ...]

      carrierSelected.clear(); // start in "all" mode

      function makeBtn(key, meta) {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "btn btn-dark btn-sm";
        btn.setAttribute("aria-pressed", "true");
        btn.dataset.key = key;
        btn.innerHTML = `<span class="swatch-dot me-2" style="background:${meta.color}"></span>${meta.friendly}`;

        btn.addEventListener("click", () => {
          if (carrierSelected.size === 0) {
            carrierSelected.add(key);
          } else {
            if (carrierSelected.has(key)) carrierSelected.delete(key);
            else carrierSelected.add(key);
          }
          syncCarrierButtons();
          refresh();
        });

        return btn;
      }

      const map = new Map(carriers); // key → meta

      // First row: 2degrees, one, spark
      primary.forEach(k => {
        if (map.has(k)) carrierBtns.appendChild(makeBtn(k, map.get(k)));
      });

      // Force new line
      const br = document.createElement("div");
      br.className = "w-100";
      carrierBtns.appendChild(br);

      // Second row: rcg, tu atea
      secondary.forEach(k => {
        if (map.has(k)) carrierBtns.appendChild(makeBtn(k, map.get(k)));
      });

      syncCarrierButtons();
    }
    buildCarrierUI();

    // -------------------------------------------------------------------------
    // Bands: same selection behaviour as carriers
    // -------------------------------------------------------------------------
    const bandSelected = new Set(); // empty => all
    let bandAllCodes = [];

    function syncBandButtons() {
      const allMode = bandSelected.size === 0;
      bandBtns.querySelectorAll("button").forEach(b => {
        const code = b.dataset.code;
        const on = allMode ? true : bandSelected.has(code);

        b.classList.toggle("btn-dark", on);
        b.classList.toggle("btn-outline-secondary", !on);
        b.setAttribute("aria-pressed", on ? "true" : "false");
      });
    }

    function buildBandUI() {
      bandBtns.innerHTML = "";
      const present = new Set(DATA.map(r => r.bandCode || "unknown"));
      const defs = BAND_DEFS
        .filter(([code]) => present.has(code))
        .map(([code, label]) => ({ code, label }));
      if (present.has("unknown")) defs.push({ code: "unknown", label: "Unknown" });
      if (present.has("other")) defs.push({ code: "other", label: "Other" });

      bandAllCodes = defs.map(d => d.code);
      bandSelected.clear(); // start in "all" mode

      defs.forEach(({ code, label }) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "btn btn-dark btn-sm";
        btn.setAttribute("aria-pressed", "true");
        btn.dataset.code = code;

        const mhz = label.split("(")[1]?.split(")")[0] ?? "";
        btn.textContent = `${code.toLowerCase()} / ${mhz}`;

        btn.addEventListener("click", () => {
          if (bandSelected.size === 0) {
            bandSelected.add(code);
          } else {
            if (bandSelected.has(code)) bandSelected.delete(code);
            else bandSelected.add(code);
          }

          syncBandButtons();
          refresh();
        });

        bandBtns.appendChild(btn);
      });

      syncBandButtons();
    }
    buildBandUI();

    // Debounced refresh to avoid glitches when typing quickly
    let refreshTimer = null;
    function refreshDebounced() {
      if (refreshTimer) clearTimeout(refreshTimer);
      refreshTimer = setTimeout(() => {
        refreshTimer = null;
        refresh();
      }, 120);
    }

     // Filter events
     [qLocation, qDistrict, qCommFrom, qCommTo, qExpFrom, qExpTo].forEach(el => {
      el.addEventListener("input", refreshDebounced);
      el.addEventListener("change", refreshDebounced);
     });

    // -------------------------------------------------------------------------
    // CONSOLIDATED DETAIL VIEW
    // - single and multi licence views are now one view
    // - if there is exactly one licence, its details auto-expand when clicked
    // -------------------------------------------------------------------------

    function renderDetailSelection(sel) {
      if (!sel || !sel.items || sel.items.length === 0) {
        detailCard.className = "text-secondary";
        detailCard.innerHTML = "Click a marker (or a recent item) to see details.";
        if (recentSection) recentSection.style.display = "";
        if (regionSection) regionSection.style.display = "";
        if (carrierSection) carrierSection.style.display = "";
        if (bandSection) bandSection.style.display = "";
        return;
      }

      if (recentSection) recentSection.style.display = "none";
      if (regionSection) regionSection.style.display = "none";
      if (carrierSection) carrierSection.style.display = "none";
      if (bandSection) bandSection.style.display = "none";

      // stable sorting: frequency asc then licenceNo
      const items = [...sel.items].sort((a, b) => {
        const fa = Number(a.refFrequencyMHz);
        const fb = Number(b.refFrequencyMHz);
        const hasFa = Number.isFinite(fa);
        const hasFb = Number.isFinite(fb);
        if (hasFa && hasFb && fa !== fb) return fa - fb;
        if (hasFa !== hasFb) return hasFa ? -1 : 1;
        return safe(a.licenceNo).localeCompare(safe(b.licenceNo));
      });

      const first = items[0];
      const districts = (first.locationDistrictNames || first.locationDistrictCodes || []).join(", ");
      const siteLabel = safe(first.location) || "Site";
      const count = items.length;

      const accId = `acc_${safe(first.carrierKey)}_${Number(sel.lat ?? first.lat).toFixed(6)}_${Number(sel.lon ?? first.lon).toFixed(6)}`
        .replace(/[^a-zA-Z0-9_]/g, "_");
      const lat = Number(sel.lat ?? first.lat);
      const lon = Number(sel.lon ?? first.lon);
      const hasCoords = Number.isFinite(lat) && Number.isFinite(lon);
      const latStr = hasCoords ? lat.toFixed(6) : "";
      const lonStr = hasCoords ? lon.toFixed(6) : "";
      const zoomLevel = 17;
      const googleSatelliteUrl = hasCoords
        ? `https://www.google.com/maps/@${latStr},${lonStr},${zoomLevel}z/data=!3m1!1e3`
        : "";
      const googleStreetUrl = hasCoords
        ? `https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=${latStr},${lonStr}`
        : "";
      const linzUrl = hasCoords
        ? `https://basemaps.linz.govt.nz/@${latStr},${lonStr},z${zoomLevel}?`
        : "";
      const linkSection = hasCoords
        ? `
          <div class="mt-2 d-flex flex-wrap gap-2">
            <a class="btn btn-sm btn-outline-secondary" href="${googleSatelliteUrl}" target="_blank" rel="noreferrer">Google Maps (Satellite)</a>
            <a class="btn btn-sm btn-outline-secondary" href="${googleStreetUrl}" target="_blank" rel="noreferrer">Google Maps (Street View)</a>
            <a class="btn btn-sm btn-outline-secondary" href="${linzUrl}" target="_blank" rel="noreferrer">LINZ Basemaps</a>
          </div>
        `
        : "";

      function renderRow(r, idx, autoOpen) {
        const rid = safe(r.id);
        const href = `https://rrf.rsm.govt.nz/ui/licence/spectrum/view/${rid}`;
        const headId = `${accId}_h_${idx}`;
        const bodyId = `${accId}_b_${idx}`;

        const compact = `
          <div class="d-flex flex-wrap gap-2 align-items-center">
            <span class="badge text-bg-dark">${safe(r.bandCode)}</span>
            <span class="badge text-bg-light">${safe(r.refFrequencyMHz)} MHz</span>
            <span class="badge text-bg-light">${Math.round(safe(r.bandwidthMHz))} MHz</span>
            <span class="ms-auto text-secondary small">${fmtDate(r.commencementDate)}</span>
          </div>
        `;

        const expanded = `
          <dl class="row mb-0 small mt-3">
            <dt class="col-5 text-secondary">Licence #</dt><dd class="col-7">${safe(r.licenceNo)}</dd>
            <dt class="col-5 text-secondary">Record ID</dt><dd class="col-7"><a href="${href}" target="_blank" rel="noreferrer">${rid}</a></dd>
            <dt class="col-5 text-secondary">Location</dt><dd class="col-7">${safe(r.location)}</dd>
            <dt class="col-5 text-secondary">District</dt><dd class="col-7">${safe(districts)}</dd>
            <dt class="col-5 text-secondary">Ref (MHz)</dt><dd class="col-7">${safe(r.refFrequencyMHz)}</dd>
            <dt class="col-5 text-secondary">Band</dt><dd class="col-7">${safe(r.bandCode)}</dd>
            <dt class="col-5 text-secondary">Bounds (MHz)</dt><dd class="col-7">${safe(r.lowerBoundMHz)} – ${safe(r.upperBoundMHz)}</dd>
            <dt class="col-5 text-secondary">Bandwidth</dt><dd class="col-7">${safe(r.bandwidthMHz)}</dd>
            <dt class="col-5 text-secondary">Power</dt><dd class="col-7">${safe(r.power)}</dd>
            <dt class="col-5 text-secondary">Commencement</dt><dd class="col-7">${fmtDate(r.commencementDate)}</dd>
            <dt class="col-5 text-secondary">Expiry</dt><dd class="col-7">${fmtDate(r.expiryDate)}</dd>
          </dl>
        `;

        const btnClass = autoOpen ? "accordion-button" : "accordion-button collapsed";
        const collapseClass = autoOpen ? "accordion-collapse collapse show" : "accordion-collapse collapse";
        const ariaExpanded = autoOpen ? "true" : "false";

        return `
          <div class="accordion-item">
            <h2 class="accordion-header" id="${headId}">
              <button class="${btnClass}" type="button"
                      data-bs-toggle="collapse" data-bs-target="#${bodyId}"
                      aria-expanded="${ariaExpanded}" aria-controls="${bodyId}">
                ${compact}
              </button>
            </h2>
            <div id="${bodyId}" class="${collapseClass}"
                 aria-labelledby="${headId}" ${count > 1 ? `data-bs-parent="#${accId}"` : ""}>
              <div class="accordion-body">
                ${expanded}
              </div>
            </div>
          </div>
        `;
      }

      const rows = items
        .map((r, i) => renderRow(r, i, count === 1)) // auto-expand only when single licence
        .join("");

      detailCard.className = "";
      detailCard.innerHTML = `
        <div class="card border-0 shadow-sm">
          <div class="card-body">
            <div class="d-flex align-items-start gap-3">
              <div class="rounded-4 p-2 text-white"
                   style="background:${safe(first.carrierColor)}; height:44px; display:flex; align-items:center; justify-content:center;">
                <span class="fw-bold" style="text-align:center;">${safe(first.carrierFriendly)}</span>
              </div>

              <div class="flex-grow-1">
                <div class="fw-semibold fs-6 mb-0">${siteLabel}</div>
                <div class="text-secondary small">${safe(districts)}</div>
              </div>

              <div class="text-end">
                <span class="badge text-bg-primary">${count} licence(s)</span>
              </div>
            </div>

            <div class="mt-3 d-flex gap-2">
              <button class="btn btn-sm btn-outline-secondary" id="clearDetailBtn" type="button">Back</button>
              <button class="btn btn-sm btn-dark" id="zoomSiteBtn" type="button" ${first.lat && first.lon ? "" : "disabled"}>Zoom</button>
            </div>
            ${linkSection}
          </div>
        </div>

        <div class="accordion mt-3" id="${accId}">
          ${rows}
        </div>
      `;

      document.getElementById("clearDetailBtn")?.addEventListener("click", () => renderDetailSelection(null));
      document.getElementById("zoomSiteBtn")?.addEventListener("click", () => {
        const r0 = items[0];
        if (r0.lat && r0.lon) map.setView([r0.lat, r0.lon], 12);
      });

      // wire per-row zoom buttons
      detailCard.querySelectorAll("button[data-zoom]").forEach(btn => {
        btn.addEventListener("click", () => {
          const idx = Number(btn.getAttribute("data-zoom"));
          const rr = items[idx];
          if (rr && rr.lat && rr.lon) map.setView([rr.lat, rr.lon], 12);
        });
      });
    }

    function getFilters() {
      return {
        locationText: (qLocation.value || "").trim().toLowerCase(),
        district: qDistrict.value || "",
        commFrom: parseDate(qCommFrom.value),
        commTo: parseDate(qCommTo.value),
        expFrom: parseDate(qExpFrom.value),
        expTo: parseDate(qExpTo.value),
      };
    }
    
    function passesBaseFilters(r, f) {
      if (f.locationText) {
        const loc = (r.location || "").toLowerCase();
        if (!loc.includes(f.locationText)) return false;
      }

      if (f.district) {
        const ds = r.locationDistrictCodes || [];
        if (!ds.includes(f.district)) return false;
      }

      const c = parseISO(r.commencementDate);
      if ((f.commFrom || f.commTo) && !c) return false;
      if (f.commFrom && c < f.commFrom) return false;
      if (f.commTo && c > f.commTo) return false;

      const e = r.expiryDate ? parseISO(r.expiryDate + "T00:00:00") : null;
      if ((f.expFrom || f.expTo) && !e) return false;
      if (f.expFrom && e < f.expFrom) return false;
      if (f.expTo && e > f.expTo) return false;

      return true;
    }

    function passesFilters(r, f) {
      if (!passesBaseFilters(r, f)) return false;

      // Carriers: selected empty => show all
      const k = r.carrierKey || "unknown";
      if (carrierSelected.size > 0 && !carrierSelected.has(k)) return false;

      // Bands: selected empty => show all
      const b = r.bandCode || "unknown";
      if (bandSelected.size > 0 && !bandSelected.has(b)) return false;

      return true;
    }

    function passesFilters(r, f) {
      if (f.locationText) {
        const loc = (r.location || "").toLowerCase();
        if (!loc.includes(f.locationText)) return false;
      }

      if (f.district) {
        const ds = r.locationDistrictCodes || [];
        if (!ds.includes(f.district)) return false;
      }

      // Carriers: selected empty => show all
      const k = r.carrierKey || "unknown";
      if (carrierSelected.size > 0 && !carrierSelected.has(k)) return false;

      // Bands: selected empty => show all
      const b = r.bandCode || "unknown";
      if (bandSelected.size > 0 && !bandSelected.has(b)) return false;

      const c = parseISO(r.commencementDate);
      if ((f.commFrom || f.commTo) && !c) return false;
      if (f.commFrom && c < f.commFrom) return false;
      if (f.commTo && c > f.commTo) return false;

      const e = r.expiryDate ? parseISO(r.expiryDate + "T00:00:00") : null;
      if ((f.expFrom || f.expTo) && !e) return false;
      if (f.expFrom && e < f.expFrom) return false;
      if (f.expTo && e > f.expTo) return false;

      return true;
    }
    
    function openFiltersIfMobile() {
      // lg breakpoint is 992px in Bootstrap 5
      if (!window.matchMedia("(max-width: 991.98px)").matches) return;

      const el = document.getElementById("filtersCanvas");
      if (!el) return;

      // If it’s already open, do nothing
      if (el.classList.contains("show")) return;

      const oc = bootstrap.Offcanvas.getOrCreateInstance(el);
      oc.show();
      setTimeout(() => map.invalidateSize(), 150);
    }

    function renderRecentList(filtered) {
      const sorted = [...filtered].sort((a, b) => {
        const da = parseISO(a.commencementDate);
        const db = parseISO(b.commencementDate);
        const ta = da ? da.getTime() : -Infinity;
        const tb = db ? db.getTime() : -Infinity;
        return tb - ta;
      });

      const top = sorted.slice(0, 10);
      recentList.innerHTML = "";

      top.forEach((r) => {
        const div = document.createElement("button");
        div.type = "button";
        div.className = "list-group-item list-group-item-action";
        div.innerHTML = `
          <div class="d-flex align-items-center gap-2">
            <span class="swatch-dot" style="background:${safe(r.carrierColor)}"></span>
            <div class="fw-semibold text-truncate">${safe(r.location)}</div>
            <span class="ms-auto badge text-bg-light">${safe(r.bandCode)}</span>
          </div>
          <div class="text-secondary small">${fmtDate(r.commencementDate)} • ${safe(r.refFrequencyMHz)} MHz</div>
        `;

        div.addEventListener("click", () => {
          // Show *all* licences at that carrier+coordinate, and auto-open the clicked one.
          const ck = r.carrierKey || "unknown";
          const lat = Number(r.lat);
          const lon = Number(r.lon);
          const key = `${ck}|${lat.toFixed(6)}|${lon.toFixed(6)}`;
          const g = currentGroups.get(key);

          const sel = g
            ? { ...g, activeId: String(r.id) }
            : { lat: r.lat, lon: r.lon, items: [r], activeId: String(r.id) };

          renderDetailSelection(sel);
          openFiltersIfMobile();
          if (r.lat && r.lon) map.setView([r.lat, r.lon], 12);
        });

        recentList.appendChild(div);
      });
    }
    
    // stash latest grouping so other UI (eg recent list clicks) can open the full group
    let currentGroups = new Map();
    let latestFiltered = [];
    
    function inMapView(r) {
      if (!r.lat || !r.lon) return false;
      const b = map.getBounds();
      return b.contains([r.lat, r.lon]);
    }

    function refreshRecentList() {
      const visible = latestFiltered.filter(r => inMapView(r));
      renderRecentList(visible);
    }

    function refresh() {
      const f = getFilters();

      // Apply ONLY non-carrier/non-band filters first
      const baseFiltered = DATA.filter(r => passesBaseFilters(r, f));

      // Update button enable/disable based on current selection + base filters
      updateAvailability(baseFiltered);

      // Now apply carrier + band selections
      const filtered = baseFiltered.filter(r => {
        const k = r.carrierKey || "unknown";
        const b = r.bandCode || "unknown";
        if (carrierSelected.size > 0 && !carrierSelected.has(k)) return false;
        if (bandSelected.size > 0 && !bandSelected.has(b)) return false;
        return true;
      });

      /*
      const missing = filtered.filter(r => !(r.lat && r.lon)).length;
      if (missing > 0) {
        coordWarn.classList.remove("d-none");
        coordWarn.textContent = `${missing} record(s) match filters but have no usable coordinates (so they won't appear on the map).`;
      } else {
        coordWarn.classList.add("d-none");
        coordWarn.textContent = "";
      }
      */

      latestFiltered = filtered;
      refreshRecentList();

      // group markers by carrier + coordinate so one marker can represent multiple licences
      markersLayer.clearLayers();
      const withCoords = filtered.filter(r => r.lat && r.lon);

      const groups = new Map();
      withCoords.forEach(r => {
        const ck = r.carrierKey || "unknown";        
        const lat = Number(r.lat);
        const lon = Number(r.lon);

        // rounding avoids float equality issues
        const key = `${ck}|${lat.toFixed(6)}|${lon.toFixed(6)}`;

        if (!groups.has(key)) {
          groups.set(key, {
            carrierKey: ck,
            carrierFriendly: r.carrierFriendly,
            carrierColor: r.carrierColor,
            lat,
            lon,
            items: []
          });
        }
        groups.get(key).items.push(r);
      });

      // make available to other UI handlers (eg recent list click -> open full group)
      currentGroups = groups;

      const groupList = [...groups.values()];

      groupList.forEach(g => {
        const color = g.carrierColor || "#666";
        const m = L.circleMarker([g.lat, g.lon], {
          radius: 6,
          color: color,
          fillColor: color,
          fillOpacity: 0.9,
          weight: 2
        });
        m.on("click", () => {
          // consolidated view always; single auto-expands inside renderDetailSelection
          renderDetailSelection(g);
          openFiltersIfMobile();
        });
        m.addTo(markersLayer);
      });

      if (withCoords.length > 0 && withCoords.length < 2000) {
        const b = L.latLngBounds(withCoords.map(r => [r.lat, r.lon]));
        map.fitBounds(b.pad(0.2));
      }
    }

    document.getElementById("recentUpdateButton")?.addEventListener("click", () => {
      refreshRecentList();
    });

    // Clear detail button in header
    document.getElementById("clearDetail")?.addEventListener("click", () => renderDetailSelection(null));

    renderDetailSelection(null);
    refresh();
  }

  init().catch(err => {
    console.error("Failed to initialize page data:", err);
    window.alert(err?.message || "Failed to load data.");
  });
  </script>
</body>
</html>
